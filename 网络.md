#  tcp和udp的区别

tcp

![image-20220321143531248](/Users/apple/Library/Application Support/typora-user-images/image-20220321143531248.png)

## 连接

tcp面向连接,udp不需要连接

## 服务对象

tcp 1to1 udp 1对多 一对一 多对一 一对多

## 可靠性

tcp可靠 可靠体现在无差错,不丢失,不重复,按需到达

udp不可靠 只是尽最大努力交付

## 拥塞控制 流量控制

tcp有 udp没有

## 首部开销

tcp首部长度较长,没有options 是20个字节

udp首部只有8个字节

## 传输

tcp流式传输,没有边界,但保证顺序和可靠

udp是一个包一个包的发送,有边界，但可能会丢包或者乱序

## 分片

tcp数据大小大于mss(最大报文段长度),会在传输层分片,目标主机收到后也会在传输层组装数据包，如果中途丢失了一个分片，只需要传输丢掉的那个分片

udp的数据大小如果大于了mtu,会在ip层分片,目标主机收到后会在ip层组装,然后在传输给传输层,如果中途丢了一个分片,还要可靠传输，就要重传所有的数据包,所以通常udp的报文应该小于mtu

## tcp可变长

udp头部长度不会变换，所以也不要字段记录udp头部长度

但是tcp有可变长的选项字段,所以需要一个字段来记录tcp头部长度

# tcp三次🤝

## 第一次🤝

客户端 随机初始化序号 client-isn 然后置于tcp头部的序号字段,同时把把syn置1, 该报文不包含应用层数据,之后客户端处于SYN-SENT状态

## 第二次🤝

收到客户端SYN 服务端也初始化自己的序号server-isn 将sever-isn放置在头部的序列号字段,同时在响应应答字段放置client-isn+1

然后把ack和syn置1 此时服务端处于SYN-RCVD状态

## 第三次🤝

响应应答字段设置为server-isn+1 并且将ack置1,这次报文可以携带应用层数据,之后客户端处于established状态

## 为什么需要3次 不是2次/4次

平庸角度:因为三次握手才能保证双方具有接受和发送的能力

tcp连接,他要保证可靠性和流量控制,从而要维护一些状态信息,这些信息包括socket,序列号,窗口大小等等

为什么要三次?

三次握手才可以阻止重复历史连接的初始化(主要原因)

首要原因就是为了防止旧的重复连接初始化造成混乱

假设客户端连续发送多条SYN建立连接的报文,网络拥堵的情况下,可能新的SYN报文对应的是服务端发来的响应旧的SYN报文的SYN+ACK报文,客户端需要判断服务端第二次握手的报文中的响应应答字段是不是旧的历史连接，如果是的,那就要发rst终止tcp连接

如果两次握手 客户端就发不了rst报文 就不能避免旧的重复连接



三次握手才可以同步双方的初始化序列号

序列号的作用

- 接受方可以去除重复的数据 不重复
- 接受方可以根据数据包的序列号按序接受 按序
- 可以标识发送的数据包中,哪些是已经被对方接受到的 不丢弃

两次握手没法保证序列号双方都确认对方接受了



三次握手才可以避免资源浪费

如果只有2次握手,客户端的syn在网络中阻塞,客户端因此也没法收到ack,所以客户端又要重新发syn,因为没有第三次握手，服务端每收到一个syn就只能主动建立一个连接,会造成冗余的无效连接,造成资源浪费

总结:两次握手没法避免旧的历史重复连接混乱,不能同步双方的序列号,会产生冗余的无效连接，造成资源浪费 四次:三次就可以了 不需要四次

# tcp粘包

两种粘包

1.接受方 tcp是面向流的协议 不会按照应用开发者的期望保持send输入数据的边界,导致接受方一次性收到多个应用层报文,需要开发者自己处理

解决  设计一个带头部的应用层报文,头部定长 特定标志开头 里面有个字段标明负载长度 接受方只要按照这个负载长度读取负载就行，其他的留在缓冲区 

规定负载的结束字符也可以 不过问题就是负载用到这些字符得转义

2.发送方 tcp为了解决报文头比负载大的情况,用了nagle算法 将多次send的数据放到了一个tcp报文

解决 屏蔽nagle算法

# tcp四次🙋

## 第一次🙋

客户端打算关闭连接,将tcp头部fin标志位置1 客户端进入FIN_WAIT_1状态

## 第二次🙋

服务端收到报文 将tcp头部的ack标志置1 服务端进入CLOSED_WAIT状态

## 第三次🙋

客户端收到服务端的ack的报文后,客户端进入了FIN_WAIT_2状态

服务端处理完数据后 向客户端发送fin报文 服务端进入LAST_ACK状态

## 第四次🙋

客户端收到了服务端的fin报文 回一个ack应答报文 之后也进入TIME_WAIT状态

服务端收到了ack报文 进入了CLOSED状态

客户端经过2MSL(TIME_WAIT)一段时间内,自动进入CLOSED状态

什么是MSL?

MSL是报文最大生存时间,超过这个时间报文会被丢弃 MSL一般大于TTL消耗到0的时间

为什么TIME_WAIT需要2倍的MSL 网络中可能还要一些来自发送方的数据包，客户端收到后再响应,一来一回正好2个msl

# 为什么需要四次挥手

关闭连接时，客户端向服务端发送fin仅仅代表客户端不再发送数据 但是还能接受数据

服务端收到客户端的fin报文 先回一个ack报文 但是此时服务端可能还有数据要处理和发送，等处理完了服务端才向客户端发送fin

# 为什么需要TIME_WAIT状态

主动发起关闭连接的一方,才会有TIME_WAIT状态

防止旧连接的数据包

防止新的连接受到旧连接因为堵塞等原因延迟到数据包影响 2个msl足以让旧连接数据包消失

等待足够的时间来确保最后的ack能够让被动关闭方接受,从而帮助其正常关闭

# tcp重传

## 超时重传

发送数据的时候 设置一个定时器,超过指定时间 没有收到对方的ack确认应答,就会重发该数据

这个时间略大于RTT

## 快重传

收到三个相同的ack报文,会在定时器过期之前,重传丢失的报文段,但是带来的问题的是不知道重传什么

于是就有了SACK方法

## SACK方法

sack(选择性确认)

在tcp头部的选项字段里加一个sack 把缓存的地图发给发送方,这样发送方就知道哪些数据收到了

## Duplicate SACK

告诉发送方哪些数据被重复接受了

# 滑动窗口

发送方窗口分为四个部分

1.已发送并且接受到ack的数据

2.已发送但未收到ack确认的数据

3.未发送但总大小还在接受方的处理范围内

4.未发送但总大小超出接受方的处理范围

四个部分需要3个指针来记录

SND.UNA是一个绝对指针 记录的是第二部分第一个的序列号

SND.NXT也是一个绝对指针 记录的是第三部分第一个的序列号

还有一个SND.WND 表示发送窗口的大小

第四部分第一个序列号 是一个相对指针 SND.UNA+SND.WND就能得到第一个的序列号

可用窗口大小用SND.WND-(SND.NXT-SND.UNA)



接受方的滑动窗口相对简单一点

分为三部分 因为接受方接受就行了 发送方不仅要发送 还需要得到ack报文 所以发送方的滑动窗口有四个部分

1.已经成功接受并且确认的数据

2.未收到但是可以接受的数据

3.超出接受能力的数据

RCV.WND 代表接受窗口的大小

RCV.NXT代表第二部分的第一个序列号

指向3 是一个相对指针 RCV.NXT+RCV.WND



# 流量控制

看一下上学期的视频

# 拥塞控制

看一下上学期的视频

慢启动

拥塞避免

拥塞发生

快速恢复



# http

# get和post区别

最直观的来说get参数在url post通过请求头传递参数

get浏览器回退是无害的，post会再次提交请求

get请求会被浏览器主动cache,post不会 需要手动设置

get请求参数会被完整保存在浏览器历史记录上

get请求在url传送的参数是有长度限制的，而post没有

对参数的数据类型，get只接受ascii字符,而post没有限制

但他们都是基于tcp/ip的,只是由于http的规定和浏览器/服务端的限制，导致了这些不同

重大区别是 get产生一个一个tcp数据包,post产生2个tcp数据包

get请求 浏览器会把http头和data一起发出去 服务器响应200

post 浏览器先发送header 服务器响应100 continue 浏览器再发送data

但也不是所有浏览器的post都发送两个tcp数据包,firefox就只发送一次

# 你知道哪些http字段

![image-20220327173143998](/Users/apple/Library/Application Support/typora-user-images/image-20220327173143998.png)

![image-20220327173245218](/Users/apple/Library/Application Support/typora-user-images/image-20220327173245218.png)

accept-encoding 客户端能接受的加密

content-encode 服务端发送数据的加密(chunked)分块流传输

客户端可以分块请求 请求头字段range 和响应头字段content-range 状态码206



![image-20220327175012954](/Users/apple/Library/Application Support/typora-user-images/image-20220327175012954.png)



![image-20220327181535221](/Users/apple/Library/Application Support/typora-user-images/image-20220327181535221.png)

samesite 导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单

只设置withCredentials已经 不够了

## http2

头部压缩 hpack 双端建立字典 用索引表示重复字符 哈夫曼编码压缩整数和数字

二进制传输 化整为零的思路

把原来的“Header+Body”的消息“打散”为数个小片的**二进制“帧”**（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。

用流id来维护 流里面放的是zhen zhen之间是有序的 
