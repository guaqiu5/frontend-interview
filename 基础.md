# m事件冒泡和事件捕获和事件代理
 两种事件流 一是由内向外直到document对象 另外是由外向内知道具体的元素 是addEventListener的第三个参数 false是冒泡 也是默认值 事件冒泡的兼容性更好一点
 实际开发 可以利用事件流的特点 使用叫事件代理的一个方法
 在事件回调函数里 通过target可以得到触发事件的那个对象,通过currentTarget可以得到绑定事件的那个对象
 比如一个ul里有几千个li 要给这个几千个li绑定事件,那得循环,性能上是有问题的,我们可以再li的父元素ul上绑定事件,利用事件冒泡机制,因为事件冒泡是从里向外直到document的，点击li会冒泡到ul 所以会执行到ul的回调函数

 阻止冒泡方法
 子元素 event.stopPropagation( )
 通过target和currentTarget判断

# 路由懒加载

也叫做组件懒加载 是为了提高首屏加载时间,利用webpack的打包机制,不用懒加载 webpack他会打包到一个js文件里面,用了懒加载,会将这个路由组件单独打包成一个js文件,激活该路由组件的时候 才会通过异步加载的方式加载这个js文件,最后动态创建script标签不是通过设置async这种来异步加载，还涉及到promise和定时器

# cdn

cdn 内容分发网络,根据用户的请求,分配离用户最近的那个缓存代理

vue项目打包 会把所有代码合并成新文件,如果有很多库,那那个js文件会特别大,引入这些库的cdn就不需要打包了,浏览器可以用多个线程引入这些库,不会影响首屏加载的时间

# token

post登陆 登陆成功了把token给浏览器,用localstorage保存,然后在请求头Authorization 字段中使用Bearer 模式添加 JWT，

# 语义化

其实div+span配合class选择器在开发的角度上来说足够用,开发和维护效率也足够高.

网页主要是给用户看的,但有时候也要关注少部分受体  比如给搜索引擎爬虫看,语义化标签可以让爬虫更懂网站的组成 所以语义化标签可以提高seo,

还有视障用户 比如网页上用div class=‘title’ XXX 我们更希望读取网页内容说的是标题 XXX 这就需要语义化标签了

还有一些需要ruby(日语 注释 注音)的场景

# 伪类和伪元素

伪类:选择器的一种 选择处于特定状态的元素，比如文档鼠标悬停在元素上面:hover, 键盘选中元素:focus 表现得像文档的某一部分应用了一个类一样

表现上就是开头为冒号的关键字

伪元素 和伪类类似 不过表现的像加入了一个全新的html标签

比如::first-line选择元素第一行

表现形式上为2个冒号 早期伪元素也用过单冒号 浏览器为了兼容也支持单冒号

# 选择器

样式类型：行内,内联,外部

id, class 属性 *  伪类 伪元素 后代 子类 兄弟



权重计算规则

第一优先级 !important 会覆盖页面任何位置

1.内联 权值1000

2.id 0100

3.类 伪类 0010

4 标签伪元素 0001

5通配符 子类 兄弟选择器 0



# src和href

src用于可替换性元素 比如img script href用于链接型元素,比如css 他是一个样式文档 不是可替代的

# flex布局

容器

flex-direction 项目排列方向 row | row-reverse | column | column-reverse

flex-wrap 如果一条轴放不下如何换行 nowrap | wrap | wrap-reverse

flex-flow 以上简写

justify-content 主轴对齐方式 flex-start | flex-end | center | space-between | space-around;

align-items 交叉轴对称方式 flex-start | flex-end | center | baseline | stretch

align-content 定义多根轴线的对齐方式 flex-start | flex-end | center | space-between | space-around | stretch

项目

order 越小越大

flex-grow

flex-shrink空间不足 等比例缩小

flex-basis 项目的容器分配空间前的默认尺寸

flex 前三者缩写 默认 0/1/auto

align-self 覆写对齐方式

# 居中方式

垂直居中:

1.justify-content align-items

2.父flex 子margin:auto

3定位 父相子绝 transform

4定位 父相子绝 上下左右0 margin:auto

5父display:table-cell text-align=center vertical-align=middle  子display:inline-block

6 父相子绝，子元素 `left , right` 各50%，再使用 `margin-left , margin-top` , 移动子元素自身宽高的一半

# 响应式布局

百分比适配:只能适配宽度 基于父级的宽度进行适配

文字宽度也是根据父级进行百分比适配 但是高度是根据文字。。。

viewport 像素比 

em

根据自身文字大小来计算大小

rem 

根据根结点(html)文字大小来计算

可以将屏幕的宽度分成若干份,然后每一个块的高宽都可以按份数来设置,具体一份的大小是通过设置html这个根结点的字体大小(window.innerWidth/份数+'px')

vw

1屏幕宽度=100vw 不用再手动算了

media 媒询 解决部分过小 影响体验





# 回旋矩阵打印 大数相加

![image-20220315221800283](/Users/apple/Library/Application Support/typora-user-images/image-20220315221800283.png)

# 权限设计



# 封装的组件

# git分支

# slot mixin

# diff算法

同层比较 深度优先

怎么同层比较

1.掐头去尾

2.老节点没 新增这个节点

 新节点没了  删除这个节点

  新老节点都有 但是乱序 

​	vue是把新的做成map(key就是节点 value是index) 遍历老的 如果老的有 复用 没有 删除

​	优化 记录复用次数 当复用次数到达新的节点数 接下来就不可能复用了 统统删除

​	还需要记录哪些节点被patch过(相对索引)  被patch的时候 记录数组的下标为新元素的相对下标，value为老元素的相对下标+1

​	新增,位置移动(最长递增子序列) 需要遍历新的(从右往左 并且用相对索引)

​	如果记录数组里的该值为0  代表没有patch过 需要新增 如果不是 

​		那就要判断要不要移动 通过最长递增子序列 来确定哪些元素呆着

​	

# webpack

entry

output

loader 默认js json

同种文件不同loader 内联加载器

plugin 在webpack运行周期运行

mode 开发 生产

devserver 小型nodejs express反向代理服务器

## sourceMap

源代码 之间的关系映射

magic-string

就是维护代码的变化(丑化 压缩)  

用途 异常监控 定位出错来源 

## chuck(优化策略)

按照依赖图进行内容组织分包

什么时候分包能够提高代码的加载速度

第三方库(放到cdn)

 懒加载 

import函数 就是动态加载 会单独组织为一个chuck

splitchucks	 

# 题目

![image-20220321171620886](/Users/apple/Library/Application Support/typora-user-images/image-20220321171620886.png)

![image-20220321172128484](/Users/apple/Library/Application Support/typora-user-images/image-20220321172128484.png)

垂直居中怎么答

如果是inline/inline-block的元素 line-height和height一样高

js直接算位置 

position margin-top

transform 针对于自己的高

flex

css的函数

![image-20220321173132807](/Users/apple/Library/Application Support/typora-user-images/image-20220321173132807.png)

滚动加载 防抖  pc/移动 

![image-20220321173513889](/Users/apple/Library/Application Support/typora-user-images/image-20220321173513889.png)

webrtc

# 原型链和继承

构造函数里有个对象 叫原型 构造函数生成的实例 有个属性__proto__可以访问构造函数的原型、

访问一个对象的属性的时候,先在自身 自身没有 到__proto__里找 __proto__就是构造函数的原型 构造函数的原型也是一个对象,也有__proto__就这样继续找 知道Object.prototype



借用构造函数继承

```javascript
//构造函数继承 没法方法复用
function Person(...arg){
  //member,methods
}
function Father(...arg){
 	 Person.call(...arg)
}

```

组合继承

```javascript
//组合继承 调用了2次父类的构造函数 消耗比较大
function Person(...arg){
  //member
}
Person.prototype.methods=()=>{
  //xxx
}
function Father(...arg){
  Person.call(...arg)
}
Father.prototype=new Person()
```

寄生式继承

```javascript
function objectCopy(obj) {
  function Fun() { };
  Fun.prototype = obj;
  return new Fun();
}
//将member挂到一个工具人的原型上

function createAnother(original) {
  let clone = objectCopy(original);
  clone.getName = function () {
    console.log(this.name);
  };
  return clone;
}

let person = {
     name: "yhd",
     friends: ["rose", "tom", "jack"]
}

let person1 = createAnother(person);
person1.friends.push("lily");
console.log(person1.friends);
person1.getName(); // yhd

let person2 = createAnother(person);
console.log(person2.friends); // ["rose", "tom", "jack", "lily"]

```

