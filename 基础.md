#  事件冒泡和事件捕获和事件代理
 两种事件流 一是由内向外直到document对象 另外是由外向内知道具体的元素 是addEventListener的第三个参数 false是冒泡 也是默认值 事件冒泡的兼容性更好一点
 实际开发 可以利用事件流的特点 使用叫事件代理的一个方法
 在事件回调函数里 通过target可以得到触发事件的那个对象,通过currentTarget可以得到绑定事件的那个对象
 比如一个ul里有几千个li 要给这个几千个li绑定事件,那得循环,性能上是有问题的,我们可以再li的父元素ul上绑定事件,利用事件冒泡机制,因为事件冒泡是从里向外直到document的，点击li会冒泡到ul 所以会执行到ul的回调函数

 阻止冒泡方法
 子元素 event.stopPropagation( )
 通过target和currentTarget判断

# 路由懒加载

也叫做组件懒加载 是为了提高首屏加载时间,利用webpack的打包机制,不用懒加载 webpack他会打包到一个js文件里面,用了懒加载,会将这个路由组件单独打包成一个js文件,激活该路由组件的时候 才会通过异步加载的方式加载这个js文件,最后动态创建script标签不是通过设置async这种来异步加载，还涉及到promise和定时器

# cdn

cdn 内容分发网络,根据用户的请求,分配离用户最近的那个缓存代理

vue项目打包 会把所有代码合并成新文件,如果有很多库,那那个js文件会特别大,引入这些库的cdn就不需要打包了,浏览器可以用多个线程引入这些库,不会影响首屏加载的时间

# token

post登陆 登陆成功了把token给浏览器,用localstorage保存,然后在请求头Authorization 字段中使用Bearer 模式添加 JWT，

# 语义化

其实div+span配合class选择器在开发的角度上来说足够用,开发和维护效率也足够高.

网页主要是给用户看的,但有时候也要关注少部分受体  比如给搜索引擎爬虫看,语义化标签可以让爬虫更懂网站的组成 所以语义化标签可以提高seo,

还有视障用户 比如网页上用div class=‘title’ XXX 我们更希望读取网页内容说的是标题 XXX 这就需要语义化标签了

还有一些需要ruby(日语 注释 注音)的场景

# 伪类和伪元素

伪类:选择器的一种 选择处于特定状态的元素，比如文档鼠标悬停在元素上面:hover, 键盘选中元素:focus 表现得像文档的某一部分应用了一个类一样

表现上就是开头为冒号的关键字

伪元素 和伪类类似 不过表现的像加入了一个全新的html标签

比如::first-line选择元素第一行

表现形式上为2个冒号 早期伪元素也用过单冒号 浏览器为了兼容也支持单冒号

# 选择器

样式类型：行内,内联,外部

id, class 属性 *  伪类 伪元素 后代 子类 兄弟



权重计算规则

第一优先级 !important 会覆盖页面任何位置

1.内联 权值1000

2.id 0100

3.类 伪类 属性 0010

4 标签伪元素 0001

5通配符 子类 兄弟选择器 0



# src和href

src用于可替换性元素 比如img script href用于链接型元素,比如css 他是一个样式文档 不是可替代的

# flex布局

容器

flex-direction 项目排列方向 row | row-reverse | column | column-reverse

flex-wrap 如果一条轴放不下如何换行 nowrap | wrap | wrap-reverse

flex-flow 以上简写

justify-content 主轴对齐方式 flex-start | flex-end | center | space-between | space-around;

align-items 交叉轴对称方式 flex-start | flex-end | center | baseline | stretch

align-content 定义多根轴线的对齐方式 flex-start | flex-end | center | space-between | space-around | stretch

项目

order 越小越大

flex-grow

flex-shrink空间不足 等比例缩小

flex-basis 项目的容器分配空间前的默认尺寸

flex 前三者缩写 默认 0/1/auto

align-self 覆写对齐方式

![image-20220328181518333](/Users/apple/Library/Application Support/typora-user-images/image-20220328181518333.png)

# 居中方式

垂直居中:

1.justify-content align-items

2.父flex 子margin:auto

3定位 父相子绝 transform

4定位 父相子绝 上下左右0 margin:auto

5父display:table-cell text-align=center vertical-align=middle  子display:inline-block

6 父相子绝，子元素 `left , right` 各50%，再使用 `margin-left , margin-top` , 移动子元素自身宽高的一半

# 响应式布局

百分比适配:只能适配宽度 基于父级的宽度进行适配

文字宽度也是根据父级进行百分比适配 但是高度是根据文字。。。

viewport 像素比 

em

根据自身文字大小来计算大小

rem 

根据根结点(html)文字大小来计算

可以将屏幕的宽度分成若干份,然后每一个块的高宽都可以按份数来设置,具体一份的大小是通过设置html这个根结点的字体大小(window.innerWidth/份数+'px')

vw

1屏幕宽度=100vw 不用再手动算了

media 媒询 解决部分过小 影响体验





# 回旋矩阵打印 大数相加

![image-20220315221800283](/Users/apple/Library/Application Support/typora-user-images/image-20220315221800283.png)

# 权限设计



# 封装的组件

# git分支

# slot mixin

# diff算法

vue的diff叫patching算法

讲讲历史 vue1是不需要diff算法的 每个依赖都会有自己的更新函数,精准更新 所以不需要vdom和patching算法  大项目内存会炸 因为粒度太细 要放一堆dep和watcher

vue2就引入虚拟dom来降低粒度 一个组件一个watcher(render watcher 还有user watcher 先不考虑user watcher) 一个watcher对应n个的dep dep触发更新函数,更新函数会再次执行render获得最新的vdom  通过对比新旧的vdom diff得到变化的地方 将其转化为dom操作

 深度优先 同层比较(因为节点大部分时间不会越层) 目的是尽可能复用

判断两个结点是否为同类 不同就删除重建

都是文本 更新文本内容

都是元素结点 递归更新子节元素 同时更新元素属性(深度优先的体现)

子新旧结点是文本/数组

如果新旧结点都是数组 这就是最复杂的部分 也是为什么要有key(双端比较)

key用index会让vue的diff优化都失效

1.掐头去尾

2.边界情况 push一个 也就是老vdom没有 新增这个结点

​	pop 新vdom没有 那就删除这个结点

3 乱序情况 vue把新的做一个map(key是结点 value是index) 然后遍历老的 老的有那就复用更新 没有的话就删除

当遍历次数达到了新的结点数 就可以停止遍历了 之后的结点全部删了 复用的时候还要记录他的索引

然后就是根据复用的结点最长递增子序列  来记录旧结点哪些可以不要动 目的就是为了最少的移动 最多的复用





## vue2



怎么同层比较

1.掐头去尾

2.老节点没 新增这个节点

 新节点没了  删除这个节点

  新老节点都有 但是乱序 

​	vue是把新的做成map(key就是节点 value是index) 遍历老的 如果老的有 复用 没有 删除

​	优化 记录复用次数 当复用次数到达新的节点数 接下来就不可能复用了 统统删除

​	还需要记录哪些节点被patch过(相对索引)  被patch的时候 记录数组的下标为新元素的相对下标，value为老元素的相对下标+1

​	新增,位置移动(最长递增子序列) 需要遍历新的(从右往左 并且用相对索引)

​	如果记录数组里的该值为0  代表没有patch过 需要新增 如果不是 

​		那就要判断要不要移动 通过最长递增子序列 来确定哪些元素呆着

​	

# webpack

entry

output

loader 默认js json

同种文件不同loader 内联加载器

plugin 在webpack运行周期运行

mode 开发 生产

devserver 小型nodejs express反向代理服务器

## sourceMap

源代码 之间的关系映射

magic-string

就是维护代码的变化(丑化 压缩)  

用途 异常监控 定位出错来源 

## chuck(优化策略)

按照依赖图进行内容组织分包

什么时候分包能够提高代码的加载速度

第三方库(放到cdn)

 懒加载 

import函数 就是动态加载 会单独组织为一个chuck

splitchucks	 

## plugin原理

htmlwebpackplugin 资源文件输出到dist目录之前(emit 阶段)

cleanwebpackplugin 打包前清理dist目录



webpack从开始打包到结束 compilewebpack对象里会暴露一些钩子,也可以说webpack的生命周期

tap tapAsync

# 题目

![image-20220321171620886](/Users/apple/Library/Application Support/typora-user-images/image-20220321171620886.png)

![image-20220321172128484](/Users/apple/Library/Application Support/typora-user-images/image-20220321172128484.png)

垂直居中怎么答

如果是inline/inline-block的元素 line-height和height一样高

js直接算位置 

position margin-top

transform 针对于自己的高

flex

css的函数

![image-20220321173132807](/Users/apple/Library/Application Support/typora-user-images/image-20220321173132807.png)

滚动加载 防抖  pc/移动 

![image-20220321173513889](/Users/apple/Library/Application Support/typora-user-images/image-20220321173513889.png)

webrtc

# 原型链和继承

构造函数里有个对象 叫原型 构造函数生成的实例 有个属性__proto__可以访问构造函数的原型、

访问一个对象的属性的时候,先在自身 自身没有 到__proto__里找 __proto__就是构造函数的原型 构造函数的原型也是一个对象,也有__proto__就这样继续找 知道Object.prototype



借用构造函数继承

```javascript
//构造函数继承 没法方法复用
function Person(...arg){
  //member,methods
}
function Father(...arg){
 	 Person.call(...arg)
}

```

组合继承

```javascript
//组合继承 调用了2次父类的构造函数 消耗比较大
function Person(...arg){
  //member
}
Person.prototype.methods=()=>{
  //xxx
}
function Father(...arg){
  Person.call(...arg)
}
Father.prototype=new Person()
```

寄生式继承

```javascript
function objectCopy(obj) {
  function Fun() { };
  Fun.prototype = obj;
  return new Fun();
}
//将member挂到一个工具人的原型上

function createAnother(original) {
  let clone = objectCopy(original);
  clone.getName = function () {
    console.log(this.name);
  };
  return clone;
}

let person = {
     name: "yhd",
     friends: ["rose", "tom", "jack"]
}

let person1 = createAnother(person);
person1.friends.push("lily");
console.log(person1.friends);
person1.getName(); // yhd

let person2 = createAnother(person);
console.log(person2.friends); // ["rose", "tom", "jack", "lily"]

```

# service worker

Service Worker 是一种独立于浏览器主线程的**工作线程**，与当前的浏览器主线程是完全隔离的，并有自己独立的执行上下文（context）。由于 Service Worker 线程是独立于主线程的工作线程，所以在 Service Worker 中的任何操作都不会影响到主线程。

改写默认行为(刷新) 离线处理

webworker WebWorker 允许在主线程之外再创建一个 worker 线程，**在主线程执行任务的同时，worker 线程也可以在后台执行它自己的任务，互不干扰**。

这样就让 JS 变成多线程的环境了，我们可以把高延迟、花费大量时间的运算，分给 worker 线程，最后再把结果返回给主线程就可以了，因为时间花费多的任务被 web worker 承担了，主线程就会很流畅了！


作者：OBKoro1
链接：https://juejin.cn/post/6844903725249593352
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 居中

行级元素 水平

1.text-align center

2.父元素 fitcontent margin auto

行级元素 垂直 单行文本 parent  line-height等于高度

块级水平

1.margin 0 auto



水平垂直居中

定位

1父相子绝 left 50% top50% 然后margin-top/left宽高的一半

2同上 left和top使用calc(50%-50px)

定位+transform:translate(-50%,-50%)

3.定位加margin auto left-bottom都设置为0

flex布局

# position

![image-20220328181658236](/Users/apple/Library/Application Support/typora-user-images/image-20220328181658236.png)

![image-20220328181707466](/Users/apple/Library/Application Support/typora-user-images/image-20220328181707466.png)

![image-20220328181718699](/Users/apple/Library/Application Support/typora-user-images/image-20220328181718699.png)

# 1

![image-20220328192345799](/Users/apple/Library/Application Support/typora-user-images/image-20220328192345799.png)

# 打包

1.分析依赖

用babel的parse 得到ast(代码词法分析后的结果 就是代码的一些信息什么的 里面的body有代码的组成部分 比如表达式 importDeclaration)

再用babel的traverse 过滤得到importDeclaration里的 然后得到依赖的路径

2.依赖->代码

transformFromAst 依赖变代码



# 两列布局

flex

左浮 右margin-left=左边宽度

左浮 右overflow:hidden

float+calc

左绝对定位 右margin-left

# vue虚拟dom

vdom是什么

虚拟的dom对象 本质上一个对象 用来描述视图结构

为什么要vdom

减少dom操作的次数 操作dom是很昂贵的 频繁操作dom会引起页面的重排和重绘

真实dom diff不需要的属性太多了 做diff会很麻烦

方便实现跨平台 vue3有个新特性 自定义渲染器 

vdom怎么生成 又怎么变成真实dom

写template 编译成渲染函数 mount过程调用render 返回的就是虚拟dom 后续patch变为真实dom 

diff算法

# vue-router

保存配置项

监听hashchange/popstate  memory(服务端模式)

根据path匹配具体的路由

实现2个全局组件router-link/router-view(利用响应式)

还有两个全局变量 route router 

# key的作用(加强)

优化diff

vue在diff的时候需要判断两个节点是否是相同节点是要看key的

没有key  类型相同vue就认为2个节点是同一个 就会触发没有必要的更新

因为undefined==undefined =true

用index发生排序变化 唯一性不能保证 vue就会判断错误

# vue异步更新策略

有数据变化 vue不会立即更新dom 而是开启一个队列 把更新函数保存在队列上 然后把这些函数利用promise的then将函数作为微任务执行(优雅降级)

# computed/watch

computed由一些值得到一个值

具有缓存性 没有异步 写一些复杂表达式 不太好维护

watch 传递一个函数 执行副作用

状态变化后做一些额外的dom操作或者异步操作

 (immediate deep)

# vue子组件和父组件

pc

cc

cm

pm

# map和object区别

map key是有序的 因此他是iterable map插入删除性能更好 map的key可以是任意类型 object有原型可能会有键名冲突的问题 object key的个数只能手动计算
